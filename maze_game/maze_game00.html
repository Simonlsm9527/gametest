<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>华旺发时尚商城</title>
    <style>
        html, body {
            height: 100%;
        }
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            font-family: Arial, sans-serif;
            color: #ff6f91;
            overflow: hidden;
        }
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 0px solid #000000;
            box-shadow: 0 0 20px #9c4459;
        }
        canvas {
            display: block;
            background-color: #ffecf0;
            width: 100%;
            height: 100%;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            justify-content: flex-end;
            z-index: 10;
        }
        #score {
            display: none !important;
        }
        #health, #health-bar {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border: 1px solid #ff6f91;
            border-radius: 5px;
        }
        #health-bar {
            margin-top: 5px;
            height: 5px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        #health-fill {
            height: 100%;
            width: 100%;
            background-color: #ff6f91;
            transition: width 0.3s ease;
        }
        #health-fill.low-health {
            background-color: #ff3366;
        }
        #start-screen, #game-over, #instructions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 20;
        }
        #instructions {
            display: none;
            padding: 20px;
            text-align: center;
            overflow-y: auto;
        }
        #game-over {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        h1 {
            color: #ff6f91;
            text-shadow: 0 0 10px #ca5a74;
            margin-bottom: 30px;
        }
        button {
            background-color: transparent;
            color: #ff6f91;
            border: 2px solid #ca5a74;
            padding: 10px 20px;
            margin: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            outline: none;
        }
        button:hover {
            background-color: #ff6f91;
            color: #000;
            box-shadow: 0 0 15px #ca5a74;
        }
        #next-level-btn {
            margin-top: 0;
            margin-bottom: 10px;
        }
        .instruction-section {
            margin-bottom: 20px;
            text-align: left;
            max-width: 500px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="800" height="600"></canvas>
        <div id="ui-container">
            <div id="score"></div>
            <div id="health">
                生命值: 10/10
                <div id="health-bar">
                    <div id="health-fill"></div>
                </div>
            </div>
        </div>
        <div id="start-screen">
            <h1></h1>
            <button id="start-btn">开始逛商场</button>
            
        </div>
        <div id="game-over">
            <h1>成功走出商场！</h1>
            <button id="restart-btn">再逛一遍</button>
            <button id="next-level-btn">下一关</button>
        </div>
        
    </div>
    <script>
        // --------------- 资源加载（图片和音效）---------------
        // 所有要替换的资源
        const mzAssets = {
            player: 'assets/mz_player.png',
            npc: 'assets/mz_npc.png',
            entrance: 'assets/mz_entrance.png',
            exit: 'assets/mz_exit.png',
            small: 'assets/mz_energy_small.png',
            large: 'assets/mz_energy_large.png',
            sfx: {
                enemyHit: 'assets/mz_enemy_hit.mp3',
                collectSmall: 'assets/mz_collect_small.mp3',
                collectLarge: 'assets/mz_collect_large.mp3',
                win: 'assets/mz_win.mp3',
                gameover: 'assets/mz_gameover.mp3'
            }
        };
        // 图片资源
        function loadImage(src) {
            const img = new Image();
            img.src = src;
            return img;
        }
        const mzImages = {
            player: loadImage(mzAssets.player),
            npc: loadImage(mzAssets.npc),
            entrance: loadImage(mzAssets.entrance),
            exit: loadImage(mzAssets.exit),
            small: loadImage(mzAssets.small),
            large: loadImage(mzAssets.large)
        };
        // 音效资源
        function createAudio(src) {
            const audio = new Audio();
            audio.src = src;
            return audio;
        }
        const mzSounds = {
            enemyHit: createAudio(mzAssets.sfx.enemyHit),
            collectSmall: createAudio(mzAssets.sfx.collectSmall),
            collectLarge: createAudio(mzAssets.sfx.collectLarge),
            win: createAudio(mzAssets.sfx.win),
            gameover: createAudio(mzAssets.sfx.gameover)
        };
        // --------------- 游戏逻辑代码 ---------------
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const healthElement = document.getElementById('health');
        const healthFill = document.getElementById('health-fill');
        const startScreen = document.getElementById('start-screen');
        const gameOverElement = document.getElementById('game-over');
        const instructionsElement = document.getElementById('instructions');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const instructionsBtn = document.getElementById('instructions-btn');
        const backBtn = document.getElementById('back-btn');
        const nextLevelBtn = document.getElementById('next-level-btn');
        let gameRunning = false;
        let health = 10;
        const maxHealth = 10;
        let frameCount = 0;
        let startTime, currentTime;
        let lastCollisionTime = 0;
        const cellSize = 40;
        const mazeWidth = Math.floor(canvas.width / cellSize);
        const mazeHeight = Math.floor(canvas.height / cellSize);
        let maze = [];
        let entrance = { x: 0, y: 0 };
        let exit = { x: 0, y: 0 };
        const player = {
            x: 0,
            y: 0,
            width: 20,
            height: 20,
            speed: 3,
            direction: 'right',
            animationCounter: 0,
            targetX: 0,
            targetY: 0,
            velX: 0,
            velY: 0
        };
        const keys = {w:false,a:false,s:false,d:false};
        let npcs = [];
        let collectibles = [];
        const colors = {
            wall: '#ffd0db',
            path: '#ff6f91',
            grid: '#ffecf0'
        };
        function generateMaze() {
            maze = Array(mazeHeight).fill().map(() => Array(mazeWidth).fill(1));
            const startX = 1, startY = 1;
            maze[startY][startX] = 0;
            entrance.x = startX * cellSize + cellSize / 2;
            entrance.y = startY * cellSize + cellSize / 2;
            const stack = [{ x: startX, y: startY }];
            const directions = [
                { x: 0, y: -2 },
                { x: 2, y: 0 },
                { x: 0, y: 2 },
                { x: -2, y: 0 }
            ];
            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const availableDirections = [];
                for (const dir of directions) {
                    const nx = current.x + dir.x;
                    const ny = current.y + dir.y;
                    if (nx > 0 && nx < mazeWidth - 1 && ny > 0 && ny < mazeHeight - 1 && maze[ny][nx] === 1) {
                        availableDirections.push(dir);
                    }
                }
                if (availableDirections.length > 0) {
                    const dir = availableDirections[Math.floor(Math.random() * availableDirections.length)];
                    const nx = current.x + dir.x;
                    const ny = current.y + dir.y;
                    maze[ny][nx] = 0;
                    maze[current.y + dir.y / 2][current.x + dir.x / 2] = 0;
                    stack.push({ x: nx, y: ny });
                } else {
                    stack.pop();
                }
            }
            for (let i = 0; i < mazeWidth * mazeHeight / 10; i++) {
                const x = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
                const y = Math.floor(Math.random() * (mazeHeight - 2)) + 1;
                if (maze[y][x] === 1) {
                    let adjacentPaths = 0;
                    if (maze[y - 1][x] === 0) adjacentPaths++;
                    if (maze[y + 1][x] === 0) adjacentPaths++;
                    if (maze[y][x - 1] === 0) adjacentPaths++;
                    if (maze[y][x + 1] === 0) adjacentPaths++;
                    if (adjacentPaths > 0) {
                        maze[y][x] = 0;
                    }
                }
            }
            let maxDistance = 0, exitX = startX, exitY = startY;
            for (let y = 1; y < mazeHeight - 1; y++) {
                for (let x = 1; x < mazeWidth - 1; x++) {
                    if (maze[y][x] === 0) {
                        const distance = Math.abs(x - startX) + Math.abs(y - startY);
                        if (distance > maxDistance) {
                            maxDistance = distance; exitX = x; exitY = y;
                        }
                    }
                }
            }
            exit.x = exitX * cellSize + cellSize / 2;
            exit.y = exitY * cellSize + cellSize / 2;
            player.x = entrance.x;
            player.y = entrance.y;
            player.targetX = player.x;
            player.targetY = player.y;
            generateNPCs();
            generateCollectibles();
        }
        function generateNPCs() {
            npcs = [];
            for (let i = 0; i < 7; i++) {
                let validPosition = false, npcX, npcY;
                while (!validPosition) {
                    const cellX = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
                    const cellY = Math.floor(Math.random() * (mazeHeight - 2)) + 1;
                    if (maze[cellY][cellX] === 0) {
                        npcX = cellX * cellSize + cellSize / 2;
                        npcY = cellY * cellSize + cellSize / 2;
                        const distToPlayer = Math.sqrt(
                            Math.pow(npcX - player.x, 2) + Math.pow(npcY - player.y, 2)
                        );
                        if (distToPlayer > 200) validPosition = true;
                    }
                }
                const moveType = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                const direction = moveType === 'horizontal' ? 
                    (Math.random() < 0.5 ? 'left' : 'right') : 
                    (Math.random() < 0.5 ? 'up' : 'down');
                npcs.push({
                    x: npcX, y: npcY,
                    width: 20, height: 20,
                    speed: 1.5, moveType: moveType,
                    direction: direction, animationCounter: Math.random() * 100
                });
            }
        }
        function generateCollectibles() {
            collectibles = [];
            for (let i = 0; i < 10; i++) generateCollectible('small');
            for (let i = 0; i < 7; i++) generateCollectible('large');
        }
        function generateCollectible(type) {
            let validPosition = false, itemX, itemY;
            while (!validPosition) {
                const cellX = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
                const cellY = Math.floor(Math.random() * (mazeHeight - 2)) + 1;
                if (maze[cellY][cellX] === 0) {
                    itemX = cellX * cellSize + cellSize / 2;
                    itemY = cellY * cellSize + cellSize / 2;
                    let overlap = false;
                    const distToPlayer = Math.sqrt(
                        Math.pow(itemX - player.x, 2) + Math.pow(itemY - player.y, 2)
                    );
                    if (distToPlayer < 100) overlap = true;
                    for (const item of collectibles) {
                        const dist = Math.sqrt(
                            Math.pow(itemX - item.x, 2) + Math.pow(itemY - item.y, 2)
                        );
                        if (dist < 60) { overlap = true; break;}
                    }
                    if (!overlap) validPosition = true;
                }
            }
            collectibles.push({
                x: itemX, y: itemY,
                width: 15, height: 15,
                type: type, collected: false, animationCounter: Math.random() * 100
            });
        }
        function drawMaze() {
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[y][x] === 1) {
                        const wallX = x * cellSize, wallY = y * cellSize;
                        ctx.fillStyle = colors.wall;
                        ctx.fillRect(wallX, wallY, cellSize, cellSize);
                        ctx.strokeStyle = '#ffecf0';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(wallX, wallY, cellSize, cellSize);
                    } else {
                        ctx.fillStyle = colors.path;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        ctx.strokeStyle = colors.grid;
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
            // 入口标记
            ctx.save();
            ctx.translate(entrance.x, entrance.y);
            ctx.drawImage(mzImages.entrance, -22.5, -22.5, 45, 45);
            ctx.restore();
            // 出口标记
            ctx.save();
            ctx.translate(exit.x, exit.y);
            ctx.drawImage(mzImages.exit, -22.5, -22.5, 45, 45);
            ctx.restore();
        }
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(0); // 可加动画
            ctx.drawImage(mzImages.player, -player.width, -player.height, player.width * 2, player.height * 2 );
            ctx.restore();
            player.animationCounter += 0.5;
        }
        function updatePlayer() {
            let dx = 0, dy = 0;
            if (keys.w) { dy -= player.speed; player.direction = 'up'; }
            if (keys.s) { dy += player.speed; player.direction = 'down'; }
            if (keys.a) { dx -= player.speed; player.direction = 'left'; }
            if (keys.d) { dx += player.speed; player.direction = 'right'; }
            const newX = player.x + dx, newY = player.y + dy;
            if (dx !== 0 || dy !== 0) {
                const playerLeft = newX - player.width / 2;
                const playerRight = newX + player.width / 2;
                const playerTop = newY - player.height / 2;
                const playerBottom = newY + player.height / 2;
                const cellLeft = Math.floor(playerLeft / cellSize);
                const cellRight = Math.floor(playerRight / cellSize);
                const cellTop = Math.floor(playerTop / cellSize);
                const cellBottom = Math.floor(playerBottom / cellSize);
                let collisionX = false, collisionY = false;
                if (dx !== 0) {
                    for (let y = cellTop; y <= cellBottom; y++) {
                        if (y < 0 || y >= mazeHeight) continue;
                        const checkX = dx > 0 ? cellRight : cellLeft;
                        if (checkX < 0 || checkX >= mazeWidth) {collisionX = true; break;}
                        if (maze[y][checkX] === 1) {collisionX = true; break;}
                    }
                    if (!collisionX) player.x = newX;
                }
                if (dy !== 0) {
                    for (let x = cellLeft; x <= cellRight; x++) {
                        if (x < 0 || x >= mazeWidth) continue;
                        const checkY = dy > 0 ? cellBottom : cellTop;
                        if (checkY < 0 || checkY >= mazeHeight) {collisionY = true; break;}
                        if (maze[checkY][x] === 1) {collisionY = true; break;}
                    }
                    if (!collisionY) player.y = newY;
                }
                const distToExit = Math.sqrt(
                    Math.pow(player.x - exit.x, 2) + Math.pow(player.y - exit.y, 2)
                );
                if (distToExit < 20) {
                    // 玩家到达出口，游戏胜利
                    mzSounds.win.currentTime = 0; mzSounds.win.play();
                    gameRunning = false;
                    gameOverElement.style.display = 'flex';
                    // 胜利时显示“下一关”按钮
                    nextLevelBtn.style.display = 'inline-block';
                }
            }
        }
        function drawNPCs() {
            npcs.forEach(npc => {
                ctx.save();
                ctx.translate(npc.x, npc.y);
                ctx.rotate(0);
                ctx.drawImage(mzImages.npc, -npc.width * 0.75, -npc.height * 0.75, npc.width * 1.5, npc.height * 1.5);
                ctx.restore();
                npc.animationCounter += 0.5;
            });
        }
        function updateNPCs() {
            npcs.forEach(npc => {
                if (npc.moveType === 'horizontal') {
                    const dx = npc.direction === 'right' ? npc.speed : -npc.speed;
                    const newX = npc.x + dx;
                    const npcLeft = newX - npc.width / 2;
                    const npcRight = newX + npc.width / 2;
                    const npcTop = npc.y - npc.height / 2;
                    const npcBottom = npc.y + npc.height / 2;
                    const cellLeft = Math.floor(npcLeft / cellSize);
                    const cellRight = Math.floor(npcRight / cellSize);
                    const cellTop = Math.floor(npcTop / cellSize);
                    const cellBottom = Math.floor(npcBottom / cellSize);
                    let collision = false;
                    for (let y = cellTop; y <= cellBottom; y++) {
                        if (y < 0 || y >= mazeHeight) continue;
                        const checkX = dx > 0 ? cellRight : cellLeft;
                        if (checkX < 0 || checkX >= mazeWidth || maze[y][checkX] === 1) {collision = true; break;}
                    }
                    if (!collision) npc.x = newX;
                    else npc.direction = npc.direction === 'right' ? 'left' : 'right';
                } else {
                    const dy = npc.direction === 'down' ? npc.speed : -npc.speed;
                    const newY = npc.y + dy;
                    const npcLeft = npc.x - npc.width / 2;
                    const npcRight = npc.x + npc.width / 2;
                    const npcTop = newY - npc.height / 2;
                    const npcBottom = newY + npc.height / 2;
                    const cellLeft = Math.floor(npcLeft / cellSize);
                    const cellRight = Math.floor(npcRight / cellSize);
                    const cellTop = Math.floor(npcTop / cellSize);
                    const cellBottom = Math.floor(npcBottom / cellSize);
                    let collision = false;
                    for (let x = cellLeft; x <= cellRight; x++) {
                        if (x < 0 || x >= mazeWidth) continue;
                        const checkY = dy > 0 ? cellBottom : cellTop;
                        if (checkY < 0 || checkY >= mazeHeight || maze[checkY][x] === 1) {collision = true; break;}
                    }
                    if (!collision) npc.y = newY;
                    else npc.direction = npc.direction === 'down' ? 'up' : 'down';
                }
                if (gameRunning && 
                    Math.abs(npc.x - player.x) < (npc.width + player.width) / 2 &&
                    Math.abs(npc.y - player.y) < (npc.height + player.height) / 2 &&
                    Date.now() - lastCollisionTime > 1000) {
                    health--;
                    lastCollisionTime = Date.now();
                    updateHealthUI();
                    mzSounds.enemyHit.currentTime = 0; mzSounds.enemyHit.play();
                    if (health <= 0) {
    // 播放失败音效
    mzSounds.gameover.currentTime = 0;
    mzSounds.gameover.play();

    // 停止游戏循环
    gameRunning = false;

    // 显示“游戏结束”界面
    gameOverElement.style.display = 'flex';
    nextLevelBtn.style.display = 'none';

    // ✅ 修改标题和按钮文本，让失败与胜利区分明显
    const title = gameOverElement.querySelector('h1');
    title.textContent = '被商场绕晕了！';
    restartBtn.textContent = '再逛一遍';
}

                }
            });
        }
        function drawCollectibles() {
            collectibles.forEach(item => {
                if (!item.collected) {
                    ctx.save();
                    ctx.translate(item.x, item.y);
                    const size = item.width * 2 * (1 + Math.sin(item.animationCounter * 0.1) * 0.2);
                    const img = item.type === 'small' ? mzImages.small : mzImages.large;
                    ctx.drawImage(img, -size/2, -size/2, size, size);
                    ctx.restore();
                    item.animationCounter += 0.5;
                }
            });
        }
        function updateCollectibles() {
            collectibles.forEach(item => {
                if (!item.collected &&
                    Math.abs(item.x - player.x) < (item.width + player.width) / 2 &&
                    Math.abs(item.y - player.y) < (item.height + player.height) / 2) {
                    item.collected = true;
                    if (item.type === 'small') {
                        health = Math.min(health + 1, maxHealth);
                        mzSounds.collectSmall.currentTime = 0; mzSounds.collectSmall.play();
                    } else {
                        health = maxHealth;
                        mzSounds.collectLarge.currentTime = 0; mzSounds.collectLarge.play();
                    }
                    updateHealthUI();
                }
            });
        }
        function updateHealthUI() {
            healthElement.textContent = `生命值: ${health}/${maxHealth}`;
            healthFill.style.width = `${(health / maxHealth) * 100}%`;
            if (health <= maxHealth / 3) {
                healthFill.classList.add('low-health');
            } else {
                healthFill.classList.remove('low-health');
            }
        }
        function gameLoop() {
            if (!gameRunning) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMaze();
            updateCollectibles();
            drawCollectibles();
            updateNPCs();
            drawNPCs();
            updatePlayer();
            drawPlayer();
            frameCount++;
            requestAnimationFrame(gameLoop);
        }
        function startGame() {
            gameRunning = true;
            health = maxHealth;
            frameCount = 0;
            startTime = Date.now();
            currentTime = startTime;
            lastCollisionTime = 0;
            generateMaze();
            updateHealthUI();
            gameOverElement.querySelector('h1').textContent = '成功走出商场！';
restartBtn.textContent = '再逛一遍';
            gameOverElement.style.display = 'none';
            startScreen.style.display = 'none';
            // 每次开始游戏时默认隐藏“下一关”按钮，避免失败时误显示
            nextLevelBtn.style.display = 'none';
            requestAnimationFrame(gameLoop);
        }
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);
        if (instructionsBtn) {
            instructionsBtn.addEventListener('click', () => {
                startScreen.style.display = 'none';
                instructionsElement.style.display = 'flex';
            });
        }
        if (backBtn) {
            backBtn.addEventListener('click', () => {
                instructionsElement.style.display = 'none';
                startScreen.style.display = 'flex';
            });
        }
        nextLevelBtn.addEventListener('click', () => {
            window.parent.postMessage('goto-level-2', '*');
        });
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
                e.preventDefault();
            }
        });
        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
                e.preventDefault();
            }
        });
        // 如果素材丢失，自动用透明占位
        for (const key in mzImages) {
            mzImages[key].onerror = function() {
                const c = document.createElement('canvas');
                c.width = c.height = 32;
                const _ctx = c.getContext('2d');
                _ctx.clearRect(0,0,32,32);
                mzImages[key].src = c.toDataURL();
            }
        }
    </script>
</body>
</html>